<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">
<head>
    <title>Linux系统学习笔记：进程间通信 - yew1eb's blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


	
    <!-- Open Graph tags -->
            <meta property="og:type" content="article"/>
            <meta property="og:title" content="Linux系统学习笔记：进程间通信"/>
            <meta property="og:url" content="../../2015/03/linux-file-ipc.html"/>
            <meta property="og:description" content="Linux系统的进程间通信（IPC）机制包括__管道(pipe)、__FIFO、消息队列、信号量(semaphore)、共享存储和__套接字(socket ..."/>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="../../theme/css/bootstrap.yeti.min.css" type="text/css"/>
    <link href="../../theme/css/font-awesome.min.css" rel="stylesheet">

    <link rel="stylesheet" href="../../theme/css/style.css" type="text/css"/>

        <link href="../../feed.xml" type="application/atom+xml" rel="alternate"
              title="yew1eb's blog RSS Feed"/>

</head>
<body>
<div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../../" class="navbar-brand">
yew1eb's blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="http://blog.csdn.net/yew1eb/">csdn博客(ACM)</a></li>
 
                         <li><a href="../../about.html">
                             关于
                          </a></li>
                         <li><a href="../../resume.html">
                             个人简历
                          </a></li>
                         <li><a href="../../books.html">
                             阅读书籍
                          </a></li>
                         <li><a href="../../demos.html">
                             个人项目
                          </a></li>
				
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li><a href="../../archives.html"><i class="fa fa-th-list"></i><span class="icon-label">归档</span></a></li>
                <li><a href="https://github.com/yew1eb"><i class="fa fa-github fa-lg"></i></a></li>
                <li><a href="http://weibo.com/yew1eb"><i class="fa fa-weibo fa-lg"></i></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="../../2015/03/linux-file-ipc.html"
                       rel="bookmark"
                       title="Permalink to Linux系统学习笔记：进程间通信">
                        Linux系统学习笔记：进程间通信
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published article_info">
        <i class="fa fa-calendar"></i><time datetime="2015-03-16T09:54:35+08:00"> 2015-03-16 09:54:35</time>
    </span>
        <span class="label label-default">By</span>
        <span class="published article_info">
            <i class="fa fa-user"></i> yew1eb
        </span>

    <span class="label label-default">Category</span>
    <span class="published article_info">
        <a href="../../category/linuxxi-tong-xue-xi-bi-ji.html">Linux系统学习笔记</a>
    </span>

	
<span class="label label-default">Tags</span>
	<a href="../../tag/linux.html">Linux</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Linux系统的进程间通信（IPC）机制包括__管道(pipe)<strong>、__FIFO</strong>、<strong>消息队列</strong>、<strong>信号量(semaphore)</strong>、共享存储和__套接字(socket)__，此外还有一些可选的如流等方式。管道、FIFO、消息队列、信号量和共享存储器属于经典的进程间通信机制，它们用于同一台主机的进程间通信。本篇总结这些进程间通信机制，下一篇总结使用套接字的进程间通信的方法。</p>
<hr />
<p>[TOC]</p>
<h2>管道</h2>
<p>管道是最古老形式的IPC，它是半双工的，而且只能在有共同祖先的进程间使用。FIFO不受进程关系的限制，UNIX域套接字则同时还是全双工的。</p>
<p>用 pipe 函数创建管道。</p>
<div class="highlight"><pre><span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cm">/* 创建管道</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="err">为读打开，</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">为写打开，</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">的输出是</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="err">的输入。</span>
</pre></div>


<p>通常在调用 pipe 的进程接着调用 fork 来创建父子进程间的IPC通道。对父进程到子进程的管道，父进程关闭 pipefd[0] ，子进程关闭 pipefd[1] ，子进程到父进程的管道相反。</p>
<p><img alt="" src="http://www.yeolar.com/media/note/2012/05/16/linux-ipc/fig1.png" />
创建从父进程到子进程的管道</p>
<p>读一个写端被关闭的管道时，在所有数据都被读取后， read 返回0，以表明到了文件结尾。写一个读端被关闭的管道时，产生 SIGPIPE 信号，如果忽略该信号或捕捉信号并从处理程序返回， write 返回-1， errno 设为 EPIPE 。</p>
<p>PIPE_BUF 规定了内核中管道缓冲区的大小，写管道或FIFO时，如果有多个进程同时写，且写的字节数超过了 PIPE_BUF ，则写数据可能穿插。</p>
<p>例：</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;sys/wait.h&gt;</span>
<span class="cp">#include &quot;error.h&quot;</span>

<span class="cp">#define DEF_PAGER   &quot;/bin/more&quot;     </span><span class="cm">/* default pager program */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">pager</span><span class="p">,</span> <span class="o">*</span><span class="n">argv0</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="kt">FILE</span>    <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: a.out &lt;pathname&gt;&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;r&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;can&#39;t open %s&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;pipe error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fork error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                           <span class="cm">/* parent */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>       <span class="cm">/* close read end */</span>
        <span class="cm">/* parent copies argv[1] to pipe */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error to pipe&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ferror</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fgets error&quot;</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>   <span class="cm">/* close write end of pipe for reader */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;waitpid error&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="cm">/* child */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>   <span class="cm">/* close write end */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">STDIN_FILENO</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STDIN_FILENO</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;dup2 error to stdin&quot;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   <span class="cm">/* don&#39;t need this after dup2 */</span>
        <span class="p">}</span>
        <span class="cm">/* get arguments for execl() */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pager</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;PAGER&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">pager</span> <span class="o">=</span> <span class="n">DEF_PAGER</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">argv0</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">argv0</span><span class="o">++</span><span class="p">;</span>        <span class="cm">/* step past rightmost slash */</span>
        <span class="k">else</span>
            <span class="n">argv0</span> <span class="o">=</span> <span class="n">pager</span><span class="p">;</span>  <span class="cm">/* no slash in pager */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">execl</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">argv0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;execl error for %s&quot;</span><span class="p">,</span> <span class="n">pager</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>标准I/O库提供了 popen 和 pclose 函数，用来处理创建管道连接另一个进程然后交换数据这种常见情况。</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cm">/* 创建管道，调用fork产生子进程，关闭管道的不使用端，用shell执行command，然后等待执行终止</span>
<span class="cm"> * @return      成功返回文件指针，出错返回NULL */</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="cm">/* 关闭标准I/O流，等待command执行结束，返回shell的终止状态</span>
<span class="cm"> * @return      成功返回command的终止状态，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
<span class="n">type</span> <span class="err">为</span> <span class="s">&quot;r&quot;</span> <span class="err">时，文件指针连接到</span> <span class="n">command</span> <span class="err">的标准输出；</span> <span class="n">type</span> <span class="err">为</span> <span class="s">&quot;w&quot;</span> <span class="err">时，文件指针连接到</span> <span class="n">command</span> <span class="err">的标准输入。</span>
</pre></div>


<p>执行 command 使用 sh -c command 的方式，因此可以执行shell扩展。</p>
<p>例：</p>
<div class="highlight"><pre><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;sys/wait.h&gt;</span>
<span class="c1">#include &quot;error.h&quot;</span>

<span class="c1">#define PAGER   &quot;${PAGER:-more}&quot; /* environment variable, or default */</span>

<span class="s-Atom">int</span> <span class="nf">main</span><span class="p">(</span><span class="s-Atom">int</span> <span class="s-Atom">argc</span><span class="p">,</span> <span class="s-Atom">char</span> <span class="o">*</span><span class="s-Atom">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="s-Atom">char</span>    <span class="s-Atom">line</span><span class="p">[</span><span class="nv">MAXLINE</span><span class="p">];</span>
    <span class="nv">FILE</span>    <span class="o">*</span><span class="s-Atom">fpin</span><span class="p">,</span> <span class="o">*</span><span class="s-Atom">fpout</span><span class="p">;</span>

    <span class="nf">if</span> <span class="p">(</span><span class="s-Atom">argc</span> <span class="p">!</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nf">err_quit</span><span class="p">(</span><span class="s2">&quot;usage: a.out &lt;pathname&gt;&quot;</span><span class="p">);</span>
    <span class="nf">if</span> <span class="p">((</span><span class="s-Atom">fpin</span> <span class="o">=</span> <span class="nf">fopen</span><span class="p">(</span><span class="s-Atom">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nv">NULL</span><span class="p">)</span>
        <span class="nf">err_sys</span><span class="p">(</span><span class="s2">&quot;can&#39;t open %s&quot;</span><span class="p">,</span> <span class="s-Atom">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nf">if</span> <span class="p">((</span><span class="s-Atom">fpout</span> <span class="o">=</span> <span class="nf">popen</span><span class="p">(</span><span class="nv">PAGER</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nv">NULL</span><span class="p">)</span>
        <span class="nf">err_sys</span><span class="p">(</span><span class="s2">&quot;popen error&quot;</span><span class="p">);</span>
    <span class="cm">/* copy argv[1] to pager */</span>
    <span class="nf">while</span> <span class="p">(</span><span class="nf">fgets</span><span class="p">(</span><span class="s-Atom">line</span><span class="p">,</span> <span class="nv">MAXLINE</span><span class="p">,</span> <span class="s-Atom">fpin</span><span class="p">)</span> <span class="p">!</span><span class="o">=</span> <span class="nv">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">if</span> <span class="p">(</span><span class="nf">fputs</span><span class="p">(</span><span class="s-Atom">line</span><span class="p">,</span> <span class="s-Atom">fpout</span><span class="p">)</span> <span class="o">==</span> <span class="nv">EOF</span><span class="p">)</span>
            <span class="nf">err_sys</span><span class="p">(</span><span class="s2">&quot;fputs error to pipe&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">if</span> <span class="p">(</span><span class="nf">ferror</span><span class="p">(</span><span class="s-Atom">fpin</span><span class="p">))</span>
        <span class="nf">err_sys</span><span class="p">(</span><span class="s2">&quot;fgets error&quot;</span><span class="p">);</span>
    <span class="nf">if</span> <span class="p">(</span><span class="nf">pclose</span><span class="p">(</span><span class="s-Atom">fpout</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nf">err_sys</span><span class="p">(</span><span class="s2">&quot;pclose error&quot;</span><span class="p">);</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>进程同步</h2>
<p>可以用管道实现父子进程间的同步。下面是用管道解决竞争条件的版本。 p 字符经由 pfd1 由父进程发送给子进程， c 字符经由 pfd2 由子进程发送给父进程。</p>
<div class="highlight"><pre><span class="nt">static</span> <span class="nt">int</span>  <span class="nt">pfd1</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="o">,</span> <span class="nt">pfd2</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="o">;</span>

<span class="nt">void</span> <span class="nt">TELL_WAIT</span><span class="o">(</span><span class="nt">void</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">pfd1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pfd2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s2">&quot;pipe error&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">void</span> <span class="nt">TELL_PARENT</span><span class="o">(</span><span class="nt">pid_t</span> <span class="nt">pid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pfd2</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="o">,</span> <span class="s2">&quot;c&quot;</span><span class="o">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">!=</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s2">&quot;write error&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">void</span> <span class="nt">WAIT_PARENT</span><span class="o">(</span><span class="nt">void</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">char</span>    <span class="n">c</span><span class="p">;</span>

    <span class="n">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pfd1</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">!=</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s2">&quot;read error&quot;</span><span class="p">);</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s2">&quot;WAIT_PARENT: incorrect data&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">void</span> <span class="nt">TELL_CHILD</span><span class="o">(</span><span class="nt">pid_t</span> <span class="nt">pid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pfd1</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="o">,</span> <span class="s2">&quot;p&quot;</span><span class="o">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">!=</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s2">&quot;write error&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">void</span> <span class="nt">WAIT_CHILD</span><span class="o">(</span><span class="nt">void</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">char</span>    <span class="n">c</span><span class="p">;</span>

    <span class="n">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pfd2</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">!=</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s2">&quot;read error&quot;</span><span class="p">);</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s2">&quot;WAIT_CHILD: incorrect data&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>协同进程</h2>
<p>过滤程序从标准输入读取数据，处理之后写到标准输出。一个程序产生过滤程序的输入，同时又读取它的输出时，该过滤程序即称为协同进程。协同进程有连接到另一个进程的两个单向管道。</p>
<p>/media/note/2012/05/16/linux-ipc/fig2.png
协同进程</p>
<p>例：</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &quot;error.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">,</span> <span class="n">int1</span><span class="p">,</span> <span class="n">int2</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">line</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="cm">/* null terminate */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sprintf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">int1</span> <span class="o">+</span> <span class="n">int2</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="s">&quot;invalid args</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &quot;error.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_pipe</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>      <span class="cm">/* our signal handler */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">,</span> <span class="n">fd1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fd2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">sig_pipe</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fd1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pipe</span><span class="p">(</span><span class="n">fd2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;pipe error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fork error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                           <span class="cm">/* parent */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error to pipe&quot;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error from pipe&quot;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err_msg</span><span class="p">(</span><span class="s">&quot;child closed pipe&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">line</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* null terminate */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fputs</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fputs error&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ferror</span><span class="p">(</span><span class="n">stdin</span><span class="p">))</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fgets error on stdin&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                    <span class="cm">/* child */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">STDIN_FILENO</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STDIN_FILENO</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;dup2 error to stdin&quot;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">STDOUT_FILENO</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDOUT_FILENO</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STDOUT_FILENO</span><span class="p">)</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;dup2 error to stdout&quot;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">execl</span><span class="p">(</span><span class="s">&quot;./add2&quot;</span><span class="p">,</span> <span class="s">&quot;add2&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;execl error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGPIPE caught</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>FIFO</h2>
<p>FIFO也称为命名管道，使用它，不相关的进程也能交换数据。</p>
<p>创建FIFO类似于创建文件，它的路径名会存在于文件系统中。也可用 mkfifo 命令创建FIFO。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>

<span class="cm">/* 创建FIFO</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">mode</span> <span class="err">参数和</span> <span class="n">open</span> <span class="err">函数中的相同。</span>
</pre></div>


<p>open 、 close 、 read 、 write 、 unlink 等文件I/O函数都可用于FIFO。</p>
<p>打开FIFO时，如果没有指定 O_NONBLOCK ，只读的 open 会阻塞直到某个进程为写而打开此FIFO，只写的 open 也会阻塞直到有进程为读打开。如果指定了 O_NONBLOCK ，只读 open 会立即返回，只写 open 如果没有相应的读进程则出错返回-1， errno 设为 ENXIO 。</p>
<p>和管道类似，读写端被关闭的FIFO会产生一个文件结束标志，写读端被关闭的FIFO产生信号 SIGPIPE 。</p>
<p>FIFO可由shell命令使用来避免创建中间临时文件，也可用于C/S架构中客户进程和服务器进程间传递数据。</p>
<h2>XSI IPC</h2>
<p>XSI IPC指消息队列、信号量和共享存储器，它们属于内核中的IPC结构。</p>
<p>内核中的IPC结构用非负整数标识符来引用，IPC标识符是累加的。标识符是IPC对象的内部名，IPC对象还有一个相关联的键作为外部名。键的类型为 key_t ，创建IPC结构时需要指定键，它会由内核变换为标识符。</p>
<p>客户进程和服务器进程访问同一个IPC结构主要有三种方式：</p>
<p>服务器进程指定 IPC_PRIVATE 来创建新的IPC结构，然后将返回的标识符通过文件或 exec 的参数（父子进程的情况）等方式告诉客户进程。
在公共头文件中定义客户进程和服务器进程都认可的键，然后服务器进程用该键来创建新的IPC结构，需要注意该键可能会已经关联了IPC结构，因此需要删除已存在的IPC结构。
用客户进程和服务器进程都认可的路径名和项目ID （0~255）来创建键，然后在方式2中使用该键。
ftok 函数由路径名和项目ID产生键。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>

<span class="cm">/* 由路径名和项目ID产生键</span>
<span class="cm"> * @return      成功返回键，出错返回-1 */</span>
<span class="kt">key_t</span> <span class="nf">ftok</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proj_id</span><span class="p">);</span>
<span class="n">pathname</span> <span class="err">必须为现存的文件，</span> <span class="n">proj_id</span> <span class="err">只被使用低</span><span class="mi">8</span><span class="err">位。</span>

<span class="n">msgget</span> <span class="err">、</span> <span class="n">semget</span> <span class="err">、</span> <span class="n">shmget</span> <span class="err">函数都有</span> <span class="n">key</span> <span class="err">和</span> <span class="n">flag</span> <span class="err">参数，如果</span> <span class="n">key</span> <span class="err">为</span> <span class="n">IPC_PRIVATE</span> <span class="err">，或</span> <span class="n">key</span> <span class="err">当前未与</span><span class="n">IPC</span><span class="err">结构关联且</span> <span class="n">flag</span> <span class="err">指定了</span> <span class="n">IPC_CREAT</span> <span class="err">位，则函数创建新的</span><span class="n">IPC</span><span class="err">结构。</span> <span class="n">IPC_PRIVATE</span> <span class="err">总是用于创建新</span><span class="n">IPC</span><span class="err">结构。</span>

<span class="err">每个</span><span class="n">IPC</span><span class="err">结构有一个</span> <span class="n">ipc_perm</span> <span class="err">结构，它限定了权限和所有者，该结构的定义如下：</span>

<span class="k">struct</span> <span class="n">ipc_perm</span> <span class="p">{</span>
    <span class="kt">__uid_t</span> <span class="n">uid</span><span class="p">;</span>                <span class="cm">/* 所有者有效用户ID */</span>
    <span class="kt">__gid_t</span> <span class="n">gid</span><span class="p">;</span>                <span class="cm">/* 所有者有效组ID */</span>
    <span class="kt">__uid_t</span> <span class="n">cuid</span><span class="p">;</span>               <span class="cm">/* 创建者有效用户ID */</span>
    <span class="kt">__gid_t</span> <span class="n">cgid</span><span class="p">;</span>               <span class="cm">/* 创建者有效组ID */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>    <span class="cm">/* 访问权限 */</span>
    <span class="cm">/* ... */</span>
<span class="p">};</span>
</pre></div>


<p>IPC结构创建时， ipc_perm 结构中的字段会被设初值，可以用 msgctl 、 semctl 、 shmctl 来修改 uid 、 gid 和 mode 字段，但进程必须是超级用户或IPC结构的创建者。</p>
<p>XSI IPC的权限位有：</p>
<p>权限  位   权限  位   权限  位
用户读 0400    组读  0040    其他读 0004
用户写（更改） 0200    组写（更改）  0020    其他写（更改） 0002
其中信号量不称为写而是更改。</p>
<p>用 ipcs -l 可以查看三种IPC的限制。</p>
<h3>消息队列</h3>
<p>消息队列是消息的链接表，存放在内核中并由消息队列ID标识。</p>
<p>每个消息队列都有一个关联的 msqid_ds 结构，它记录了消息队列的当前状态，该结构的定义如下：</p>
<div class="highlight"><pre>struct msqid_ds {
    struct ipc_perm msg_perm;
    time_t          msg_stime;    /* 上次msgsnd的时间 */
    time_t          msg_rtime;    /* 上次msgrcv的时间 */
    time_t          msg_ctime;    /* 上次修改的时间 */
    unsigned long   __msg_cbytes; /* 队列中当前字节数 */
    msgqnum_t       msg_qnum;     /* 队列中当前消息数 */
    msglen_t        msg_qbytes;   /* 队列的最大字节数 */
    pid_t           msg_lspid;    /* 上次msgsnd的进程ID */
    pid_t           msg_lrpid;    /* 上次msgrcv的进程ID */
};
</pre></div>


<p>msgget 函数创建新消息队列或打开现存的消息队列。创建新队列时， msgflg 指定 msg_perm.mode 的权限位设置。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/msg.h&gt;</span>

<span class="cm">/* 创建新消息队列或打开现存的消息队列</span>
<span class="cm"> * @return      成功返回消息队列ID，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="n">msgctl</span> <span class="err">函数执行对消息队列的操作。</span>
</pre></div>


<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/msg.h&gt;</span>

<span class="cm">/* 执行对消息队列的操作</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">msgctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msqid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="n">cmd</span> <span class="err">参数指定要执行的命令，有：</span>

<span class="n">IPC_STAT</span> <span class="err">：获取消息队列的</span> <span class="n">msqid_ds</span> <span class="err">结构，保存在</span> <span class="n">buf</span> <span class="err">中。</span>
<span class="n">IPC_SET</span> <span class="err">：根据</span> <span class="n">buf</span> <span class="err">指向结构的值，设置</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">、</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">gid</span> <span class="err">、</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">mode</span> <span class="err">、</span> <span class="n">msg_qbytes</span> <span class="err">。进程必须是超级用户进程或有效用户</span><span class="n">ID</span><span class="err">等于</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">cuid</span> <span class="err">或</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">，增加</span> <span class="n">msg_qbytes</span> <span class="err">的值则必须是超级用户。</span>
<span class="n">IPC_RMID</span> <span class="err">：从系统中删除消息队列和其中的所有数据，删除会立即生效。进程必须是超级用户进程或有效用户</span><span class="n">ID</span><span class="err">等于</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">cuid</span> <span class="err">或</span> <span class="n">msg_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">。</span>
<span class="n">msgsnd</span> <span class="err">函数将消息放到消息队列中，</span> <span class="n">msgrcv</span> <span class="err">函数从消息队列中取消息。消息总是添加在队列末尾。函数成功返回时，内核会更新和消息队列关联的</span> <span class="n">msqid_ds</span> <span class="err">结构。</span>
</pre></div>


<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/msg.h&gt;</span>

<span class="cm">/* 将消息放到消息队列中</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msgp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msgsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="cm">/* 从消息队列中取消息</span>
<span class="cm"> * @return      成功返回消息的数据部分的长度，出错返回-1 */</span>
<span class="kt">ssize_t</span> <span class="nf">msgrcv</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msgp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msgsz</span><span class="p">,</span> <span class="kt">long</span> <span class="n">msgtyp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="n">msgp</span> <span class="err">指向一个长整型数，它包含正整数的消息类型，在后面是消息数据，</span> <span class="n">msgsz</span> <span class="err">给出消息数据的长度，它可以为</span><span class="mi">0</span><span class="err">。若发送</span><span class="mi">1</span><span class="err">字节数据的消息，可以定义消息的结构为：</span>

<span class="k">struct</span> <span class="n">msgbuf</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">mtype</span><span class="p">;</span>     <span class="cm">/* 消息类型，&gt;0 */</span>
    <span class="kt">char</span> <span class="n">mtext</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* 消息数据 */</span>
<span class="p">};</span>
<span class="err">可以用消息类型来以非先进先出的次序取消息。</span>
</pre></div>


<p>msgtyp 可以指定需要的消息：</p>
<p>= 0 时，返回消息队列中的第一个消息。</p>
<blockquote>
<p>0 时，返回消息队列中消息类型为 msgtyp 的第一个消息。
&lt; 0 时，返回消息队列中消息类型小于等于 msgtyp 绝对值的消息，取其中类型值最小者。
对 msgsnd ， msgflg 指定为 IPC_NOWAIT 时，若消息队列已满，立即出错返回；若没有指定，则进程阻塞，直到有空间、消息队列被删除或捕捉到信号为止。对 msgrcv ， msgflg 指定为 IPC_NOWAIT 时，若没有指定的消息，立即出错返回；若没有指定，同样阻塞进程。</p>
</blockquote>
<p>msgflg 设置 MSG_NOERROR 时，若 msgrcv 返回的消息大于 msgsz ，则自动截短；若没设置而消息过长时，会出错返回，消息留在消息队列中。</p>
<p>信号量</p>
<p>信号量是一个计数器，用于多进程对共享数据对象的访问。进程获取共享资源时，测试控制该资源的信号量。若信号量的值为正，则进程可以使用资源，进程将信号量的值减1；若信号量的值为0，则进程休眠直到信号量的值大于0。进程不再使用资源时，信号量的值加1，如果有休眠等待的进程，则唤醒它们，进程被唤醒后，重新测试。</p>
<p>信号量集是一个或多个信号量的集合，内核为每个信号量集设置了一个 semid_ds 结构，它的定义如下：</p>
<div class="highlight"><pre>struct semid_ds {
    struct ipc_perm sem_perm;
    time_t          sem_otime; /* 上次semop的时间 */
    time_t          sem_ctime; /* 上次修改的时间 */
    unsigned short  sem_nsems; /* 信号量数量 */
};
</pre></div>


<p>每个信号量是一个无名结构，包含下列成员：</p>
<p>unsigned short  semval;   /<em> 信号量的值，&gt;=0 </em>/
unsigned short  semzcnt;  /<em> 等待信号量的值为0的进程 </em>/
unsigned short  semncnt;  /<em> 等待信号量的值增加的进程 </em>/
pid_t           sempid;   /<em> 上次操作的进程ID </em>/
semget 函数创建新信号量集或引用现存的信号量集。创建新信号量集时， nsems 指定 sem_nsems ， semflg 指定 sem_perm.mode 的权限位设置。引用现存的信号量集时， nsems 设为0。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/sem.h&gt;</span>

<span class="cm">/* 创建新信号量集或引用现存的信号量集</span>
<span class="cm"> * @return      成功返回信号量集ID，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">);</span>
<span class="n">semctl</span> <span class="err">函数执行对信号量的操作。</span>

<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/sem.h&gt;</span>

<span class="cm">/* 执行对信号量的操作 */</span>
<span class="kt">int</span> <span class="n">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* union semun arg */</span><span class="p">);</span>
<span class="err">第四个参数是可选的，它的类型为联合</span> <span class="n">semun</span> <span class="err">，该联合的定义如下：</span>

<span class="k">union</span> <span class="n">semun</span> <span class="p">{</span>
    <span class="kt">int</span>             <span class="n">val</span><span class="p">;</span>    <span class="cm">/* 用于SETVAL的值 */</span>
    <span class="k">struct</span> <span class="n">semid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>   <span class="cm">/* 用于IPC_STAT, IPC_SET的缓冲 */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="o">*</span><span class="n">array</span><span class="p">;</span> <span class="cm">/* 用于GETALL, SETALL的数组 */</span>
    <span class="k">struct</span> <span class="n">seminfo</span>  <span class="o">*</span><span class="n">__buf</span><span class="p">;</span> <span class="cm">/* 用于IPC_INFO的缓冲 */</span>
<span class="p">};</span>
</pre></div>


<p>cmd 参数可以指定的命令有：</p>
<p>IPC_STAT ：取信号量集的 semid_ds 结构，存放在 arg.buf 指向的结构中。
IPC_SET ：根据 arg.buf 指向的结构中的值设置信号量集 semid_ds 结构中的 sem_perm.uid 、 sem_perm.gid 、 sem_perm.mode 。进程必须是超级用户进程或有效用户ID等于 sem_perm.cuid 或 sem_perm.uid 。
IPC_RMID ：从系统中删除信号量集，删除会立即生效。进程必须是超级用户进程或有效用户ID等于 sem_perm.cuid 或 sem_perm.uid 。
GETVAL ：获取 semnum 指定的信号的 semval 值。
SETVAL ：根据 arg.val 设置 semnum 指定的信号的 semval 值。
GETZCNT ：获取 semnum 指定的信号的 semzcnt 值。
GETNCNT ：获取 semnum 指定的信号的 semncnt 值。
GETPID ：获取 semnum 指定的信号的 sempid 值。
GETALL ：获取信号量集中所有信号量的值，存放在 arg.array 指向的数组中。
SETALL ：根据 arg.array 指向的数组中的值设置信号量集中所有信号量的值。
针对特定信号量时，用 semnum 指定信号量，它取0到 nsems-1 之间的值。</p>
<p>除 GETALL 之外的 GET 命令，函数返回结果，其他命令函数返回0，出错时返回-1。</p>
<p>semop 自动执行信号量集上的操作数组。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/sem.h&gt;</span>

<span class="cm">/* 执行信号量集上的操作数组</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">semtimedop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span>
               <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
<span class="n">sops</span> <span class="err">参数指向信号量操作数组，信号量操作由</span> <span class="n">sembuf</span> <span class="err">结构表示：</span>

<span class="k">struct</span> <span class="n">sembuf</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sem_num</span><span class="p">;</span> <span class="cm">/* semnum */</span>
    <span class="kt">short</span>    <span class="n">sem_op</span><span class="p">;</span>        <span class="cm">/* 操作 */</span>
    <span class="kt">short</span>    <span class="n">sem_flg</span><span class="p">;</span>       <span class="cm">/* 操作选项 */</span>
<span class="p">};</span>
</pre></div>


<p>nsops 参数指定数组的元素数。</p>
<p>sem_op 有三种取值：</p>
<blockquote>
<p>0 时，表示释放该信号量控制的资源。信号量的值加上 sem_op ，若 sem_flg 指定了 SEM_UNDO ，则同时信号量的调整值减去 sem_op 。
&lt; 0 时，表示获取该信号量控制的资源。若信号量的值大于等于 sem_op 的绝对值，即具有所需的资源：信号量的值减去 sem_op 的绝对值，若 sem_flg 指定了 SEM_UNDO ，则同时信号量的调整值加上 sem_op 的绝对值。若信号量的值小于 sem_op 的绝对值，即资源不能满足需求：
若 sem_flg 指定了 IPC_NOWAIT ，则函数出错返回。
若没指定 IPC_NOWAIT ，信号量的 semncnt 值加1，挂起进程直到：
信号量大于等于 sem_op 的绝对值，即有进程释放了一些资源，然后 semncnt 减1，并如获取资源时那样减小信号量的值等等。
从系统中删除了信号量，这时函数出错返回。
进程捕捉到信号，这时信号量的 semncnt 减1，函数出错返回。
= 0 时，表示进程希望等待到信号量的值变为0。若信号量的值为0，函数立即返回。若信号量的值非0，和2中信号量的值小于 sem_op 的绝对值时的情况类似，区别是信号量和0比较。
进程终止时，如果它占用了信号量分配的资源，信号量不会调整，这会造成麻烦。信号量操作指定 SEM_UNDO 标志时，进程终止时内核会进行检查并根据调整值进行处理。</p>
</blockquote>
<p>用 SETVAL 或 SETALL 命令的 semctl 函数设置信号量的值时，该信号量的调整值会被设为0，这对所有进程有效。</p>
<p>共享存储</p>
<p>共享存储允许两个或更多进程共享给定的存储区，它是最快的一种IPC。使用共享存储时要处理多个进程间的同步，这可以使用信号量或记录锁。共享存储可由不相关的进程使用，如果进程是相关的，也可以使用 mmap 来处理。</p>
<p>在地址空间中，共享存储紧靠在栈之下。</p>
<p>内核为每个共享存储段设置了一个 shmid_ds 结构，它的定义如下：</p>
<p>struct shmid_ds {
    struct ipc_perm shm_perm;
    size_t          shm_segsz;   /<em> 段字节数 </em>/
    time_t          shm_atime;   /<em> 上次连接时间 </em>/
    time_t          shm_dtime;   /<em> 上次脱接时间 </em>/
    time_t          shm_ctime;   /<em> 上次修改时间 </em>/
    pid_t           shm_cpid;    /<em> 创建者进程ID </em>/
    pid_t           shm_lpid;    /<em> 上次shmat/shmdt的进程ID </em>/
    shmatt_t        shm_nattch;  /<em> 当前连接者数目 </em>/
    /<em> ... </em>/
};
shmget 函数创建新共享存储段或引用现存的共享存储段。创建新共享存储段时， size 指定 shm_segsz ， shmflg 指定 shm_perm.mode 的权限位设置。引用现存的共享存储段时， size 设为0。创建新段时，段的内容会初始化为0。</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/shm.h&gt;</span>

<span class="cm">/* 创建新共享存储段或引用现存的共享存储段</span>
<span class="cm"> * @return      成功返回共享存储ID，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">shmget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
<span class="n">shmctl</span> <span class="err">函数执行对共享存储段的操作。</span>
</pre></div>


<div class="highlight"><pre><span class="cp">#include &lt;sys/ipc.h&gt;</span>
<span class="cp">#include &lt;sys/shm.h&gt;</span>

<span class="cm">/* 执行对共享存储段的操作</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">shmctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="n">cmd</span> <span class="err">参数可以指定为：</span>

<span class="n">IPC_STAT</span> <span class="err">：获取共享存储段的</span> <span class="n">shmid_ds</span> <span class="err">结构，保存在</span> <span class="n">buf</span> <span class="err">中。</span>
<span class="n">IPC_SET</span> <span class="err">：根据</span> <span class="n">buf</span> <span class="err">指向结构的值，设置</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">、</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">gid</span> <span class="err">、</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">mode</span> <span class="err">。进程必须是超级用户进程或有效用户</span><span class="n">ID</span><span class="err">等于</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">cuid</span> <span class="err">或</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">。</span>
<span class="n">IPC_RMID</span> <span class="err">：从系统中删除共享存储段，此时不能再连接该段，但直到使用该段的最后一个进程终止或和该段脱接时才会实际删除该段。进程必须是超级用户进程或有效用户</span><span class="n">ID</span><span class="err">等于</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">cuid</span> <span class="err">或</span> <span class="n">shm_perm</span><span class="p">.</span><span class="n">uid</span> <span class="err">。</span>
<span class="n">SHM_LOCK</span> <span class="err">：将共享存储段锁定在内存中，只能由超级用户执行。</span>
<span class="n">SHM_UNLOCK</span> <span class="err">：将共享存储段解锁，只能由超级用户执行。</span>
<span class="err">进程可以用</span> <span class="n">shmat</span> <span class="err">函数将共享存储段连接到它的地址空间中，用</span> <span class="n">shmdt</span> <span class="err">函数脱接共享存储段。执行成功时</span> <span class="n">shm_nattch</span> <span class="err">会相应地加减</span><span class="mi">1</span><span class="err">。</span>
</pre></div>


<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/shm.h&gt;</span>

<span class="cm">/* 将共享存储段连接到进程的地址空间中</span>
<span class="cm"> * @return      成功返回指向共享存储的指针，出错返回-1 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
<span class="cm">/* 脱接共享存储段</span>
<span class="cm"> * @return      成功返回0，出错返回-1 */</span>
<span class="kt">int</span> <span class="nf">shmdt</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">);</span>
</pre></div>


<p>若 shmaddr 为0，则共享存储段连接到内核选择的第一个地址上。若 shmaddr 非0，且 shmflg 没有指定 SHM_RND ，则共享存储段连接到 shmaddr 指定的地址上；若 shmflg 指定了 SHM_RND ，则将 shmaddr 向下取整（ SHMLBA 的倍数）。一般将 shmaddr 设为0。</p>
<p>shmflg 中指定了 SHM_RDONLY 位时以只读方式连接共享存储段，否则以读写方式连接。</p>
<p>脱接共享存储段时并不删除共享存储段，删除它需要使用 IPC_RMID 命令的 shmctl 函数。</p>
<h2>XSI IPC的一些问题</h2>
<p>消息队列、信号量和共享存储实现在内核中，通常它们的效率较高。</p>
<p>此外，把消息队列和其他的IPC进行比较：</p>
<p>IPC类型   无连接 可靠  流控制 记录  消息类型或优先级
消息队列    否   是   是   是   是
STREAMS 否   是   是   是   是
FIFO    否   是   是   否   否
UNIX域流套接字   否   是   是   否   否
UNIX域数据报套接字 是   是   否   是   否
无连接指不需要某种创建就能发送消息；流控制指不能接收更多消息时发送进程休眠。</p>
<p>XSI IPC的缺点是这些IPC结构在系统范围内生效，没有访问计数，创建它的进程终止时，IPC结构会遗留在系统中，直到用 xxxctl 函数显式地删除（或者是执行 ipcrm 命令、重启系统）。</p>
<p>另一个缺点是它们不具有文件系统中的名字，所以不能使用 select 和 poll 等函数同时处理多个IPC结构。</p>
<p>一般建议用全双工管道和记录锁代替使用消息队列和信号量，可以考虑用 mmap 函数代替共享存储，它们的使用要更为简单。</p>
            </div>
            <br />
    <!-- JiaThis Button BEGIN -->
    <hr />
    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微薄</a>
    <a class="jiathis_button_tqq">腾讯微薄</a>
    <a class="jiathis_button_renren">人人网</a>
    <a class="jiathis_button_kaixin001">开心网</a>

    <a href="http://www.jiathis.com/share?uid=1904070" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
    </div>
    <script type="text/javascript" >
    var jiathis_config={
        data_track_clickback:true,
        summary:"",
        shortUrl:false,
        hideMore:false
    }
    </script>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1904070" charset="utf-8"></script>
    <!-- JiaThis Button END -->

    <div>
        <br />
        <hr />
        <ul>
            <li>
                <a href="../../2015/03/linux-file-io.html">
                    上一篇文章：Linux系统学习笔记：文件 IO
                </a>
            </li>
            <li>
                <a href="../../2015/03/linux-process.html">
                    下一篇文章：Linux系统学习笔记：进程
                </a>
            </li>
        </ul>
    </div>
			
			
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="linux-file-ipc" 
	data-title="Linux系统学习笔记：进程间通信" data-url="../../2015/03/linux-file-ipc.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"yew1eb"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->


        </article>
    </section>

        </div>
	
        <div class="col-sm-3 well well-sm" id="sidebar">

<aside>
    <section>
        <ul class="list-group list-group-flush">
                <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">最新日志</span></h4>
                    <ul class="list-group" id="recentposts">
                        <li class="list-group-item">
                            <a href="../../2015/04/linux-File_attribute_and_authority.html">
                                Linux系统学习笔记：文件属性与权限
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../2015/03/C_plus_plus_struct.html">
                                c++中的结构体大小计算（内存对齐）
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../2015/03/C_plus_plus_volatile.html">
                                c++中的volatile关键字
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../2015/03/C_plus_plus_virtual.html">
                                C++中的虚函数
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../2015/03/linux-process.html">
                                Linux系统学习笔记：进程
                            </a>
                        </li>
                    </ul>
                </li>

                <li class="list-group-item"><a href="../../category/index.html"><h4><i class="fa fa-coffee fa-lg"></i><span class="icon-label">日志分类</span></h4></a>
                    <ul class="list-group" id="categories">
                        <li class="list-group-item">
                            <a href="../../category/cc.html">
                                <i class="fa fa-folder-open fa-lg"></i> C/C++
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../category/linuxxi-tong-xue-xi-bi-ji.html">
                                <i class="fa fa-folder-open fa-lg"></i> Linux系统学习笔记
                            </a>
                        </li>
                        <li class="list-group-item">
                            <a href="../../category/ri-chang.html">
                                <i class="fa fa-folder-open fa-lg"></i> 日常
                            </a>
                        </li>
                    </ul>
                </li>

                <li class="list-group-item"><a href="../../tag/index.html"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">标签云</span></h4></a>
                    <ul class="list-group" id="tags">
                        <span class="list-group-item tag-4">
                            <a href="../../tag/pelican.html">
                                pelican
                            </a>
                        </span>
                        <span class="list-group-item tag-1">
                            <a href="../../tag/cc.html">
                                C/C++
                            </a>
                        </span>
                        <span class="list-group-item tag-4">
                            <a href="../../tag/xu-han-shu.html">
                                虚函数
                            </a>
                        </span>
                        <span class="list-group-item tag-1">
                            <a href="../../tag/linux.html">
                                Linux
                            </a>
                        </span>
                        <span class="list-group-item tag-4">
                            <a href="../../tag/markdown.html">
                                Markdown
                            </a>
                        </span>
                        <span class="list-group-item tag-2">
                            <a href="../../tag/volatile.html">
                                volatile
                            </a>
                        </span>
                        <span class="list-group-item tag-4">
                            <a href="../../tag/make.html">
                                Make
                            </a>
                        </span>
                    </ul>
                </li>


    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">友情链接</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://blog.csdn.net/yew1eb/" target="_blank">
                我的csdn博客
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
      </ul>
    </li>

        </ul>
    </section>

</aside>        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2015 yew1eb
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
			.&nbsp
			<script src="http://s9.cnzz.com/stat.php?id=1254417815&web_id=1254417815&show=pic" language="JavaScript"></script>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="../../theme/js/jquery.min.js"></script>
<script src="../../theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="../../theme/js/respond.min.js"></script>

<!-- For the Tags Cloud -->
<script type="text/javascript">
</script>



</body>
</html>