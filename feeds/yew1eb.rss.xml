<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>yew1eb's blog</title><link>yew1eb.github.io/</link><description></description><atom:link href="yew1eb.github.io/feeds%5Cyew1eb.rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 14 Mar 2015 12:15:15 +0800</lastBuildDate><item><title>Linux系统学习笔记：文件 IO</title><link>yew1eb.github.io/2015/03/linux-file-io.html</link><description>&lt;p&gt;Linux系统中的文件IO主要用到5个函数：open、read、write、lseek、close。这些函数被称为不带缓冲的IO（unbuff IO），不带缓冲指的是每个read和write都调用内核中的一个系统调用。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;1.文件描述符&lt;/h2&gt;
&lt;p&gt;在Linux下用文件描述符来表示设备文件和普通文件，所有对文件的操作都通过文件描述符实现。文件描述符是一个非负整数。&lt;br /&gt;
按惯例，shell中为每个进程都关联了3个文件即： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准输入      0   STDIN_FILENO &lt;/li&gt;
&lt;li&gt;标准输出      1   STDOUT_FILENO&lt;/li&gt;
&lt;li&gt;标准错误输出    2   STDERR_FILENO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个符号常量定义在&lt;unistd.h&gt;中&lt;/p&gt;
&lt;h2&gt;2.标准IO函数&lt;/h2&gt;
&lt;h3&gt;1.open和creat&lt;/h3&gt;
&lt;p&gt;使用open和creat打开或创建文件。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;oflag&lt;/span&gt;&lt;span class="p"&gt;,...&lt;/span&gt;&lt;span class="cm"&gt;/* mode_t mode */&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;creat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;mode_t&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* 若操作成功，则返回文件描述符；若出错，返回-1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数说明：&lt;br /&gt;
path &lt;br /&gt;
要打开或创建的文件的路径名（相对或者绝对路径）&lt;/p&gt;
&lt;p&gt;oflag&lt;br /&gt;
多个选项时用'|'隔开，这些常量定义在 &lt;fcntl.h&gt;中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O_RDONLY&lt;/li&gt;
&lt;li&gt;O_WRONLY&lt;/li&gt;
&lt;li&gt;O_RDWR  &lt;/li&gt;
&lt;li&gt;O_EXEC 只执行打开&lt;/li&gt;
&lt;li&gt;O_SEARCH 只搜索打开
&lt;em&gt;以上5个选项必须有且只有一个。下列常量则是可选的&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;O_APPEND 每次谢都追加到文件尾&lt;/li&gt;
&lt;li&gt;O_CREAT 若此文件不存在则创建它，使用此选项是，open函数需同时说明第3个参数mode（访问权限），此时open函数功能和creat函数一样。&lt;/li&gt;
&lt;li&gt;O_DIRECTORY 如果path引用的不是目录，则出错。&lt;/li&gt;
&lt;li&gt;O_EXCL 如果同时指定了 O_CREAT，而文件已经存在，则出错。 文件不存在则创建文件，使测试和创建成为一个原子操作。&lt;/li&gt;
&lt;li&gt;O_NOCTTY 对于终端设备，不将该设备分配为此进程的控制终端。&lt;/li&gt;
&lt;li&gt;O_NOFOLLOW 若path引用的是一个符号链接，则出错。&lt;/li&gt;
&lt;li&gt;O_NONBLOCK 对于FIFO、块特殊文件、字符特殊文件，设为非阻塞模式。&lt;/li&gt;
&lt;li&gt;O_SYNC write 等待物理I/O操作完成，包括文件属性的更新。&lt;/li&gt;
&lt;li&gt;O_TRUNC 如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0。&lt;/li&gt;
&lt;li&gt;O_TTY_INIT 如果打开一个还未打开的终端设备，设置非标准 termios参数值，使其符合Single UNIX Specification。&lt;/li&gt;
&lt;li&gt;O_DSYNC  write 等待物理I/O操作完成，若写不影响读取（如文件大小没变化），不等待文件属性的更新&lt;/li&gt;
&lt;li&gt;O_RSYNC 与O_SYNC作用相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mode&lt;br /&gt;
指定用户操作文件的权限，常用可选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S_IRWXU 用户有读写和执行的权限&lt;/li&gt;
&lt;li&gt;S_IRUSR 用户对文件有读权限&lt;/li&gt;
&lt;li&gt;S_IWUSR 用户对文件有写权限&lt;/li&gt;
&lt;li&gt;S_IXUSR 用户对文件有执行权限&lt;/li&gt;
&lt;li&gt;...  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.close&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* 成功返回0，出错返回-1*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关闭文件时会释放该进程加在文件上的所有记录锁。进程终止时，内核会自动关闭它打开的文件。&lt;/p&gt;
&lt;h3&gt;3.lseek&lt;/h3&gt;
&lt;p&gt;每个打开文件都用一个与其相关联的“当前文件偏移量”，通常为一个非负整数，表示从文件开始的字节数。读/写操作从当前文件偏移量处开始，使偏移量增加读写的字节数。默认打开文件偏移量为0，以 O_APPEND 打开偏移量为文件的字节数。可以用 lseek 设置文件的偏移量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="nf"&gt;lseek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;whence&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*若成功，返回新的文件偏移量；若出错，返回为-1*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;offset
要增加的偏移量
whence
+ SEEK_SET，相对文件开始处
+ SEEK_CUR， 相对文件当前位置
+ SEEK_END， 相对文件结尾处&lt;/p&gt;
&lt;p&gt;lseek 并不引起I/O操作，偏移量记录在内核中。
普通文件的偏移量必须是非负整数。偏移量可以大于文件的长度，这样之后的写会形成一个空洞，空洞不占存储，其中的字节被读为0。可以写一个这样的文件，用 od -c 命令验证一下，还可用 ls -ls 命令查看磁盘块占用情况。&lt;/p&gt;
&lt;h3&gt;4.read&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*成功返回读到的字节数，已到文件尾返回0，出错返回-1 */&lt;/span&gt;&lt;span class="err"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;受文件大小、网络缓冲区、管道、FIFO的实际字节数的限制，实际读到的数据可能少于要读的字节数，信号中断也会造成这种情况。终端设备通常一次最多读一行，磁带等设备一次最多读一个记录。&lt;/p&gt;
&lt;h3&gt;5.write&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于普通文件，在操作从文件的当前偏移量开始。若文件打开时指定了 O_APPEND 选项，则写之前将偏移量设置到文件结尾处。&lt;/p&gt;
&lt;h2&gt;3.文件共享&lt;/h2&gt;
&lt;p&gt;UNIX支持不同进程共享打开的文件。内核使用三种数据结构表示打开的文件：&lt;/p&gt;
&lt;p&gt;进程在进程表中都有一个记录项，包含一张打开文件的描述符表。每个描述符占一项，包含描述符标志和指向一个文件表项的指针。
&lt;em&gt; 内核维持一张所有打开文件的文件表，每个文件表项包含文件状态标志、当前文件偏移量、指向文件v节点表项的指针。
&lt;/em&gt; 每个打开文件有一个v节点表，每个v节点包含文件类型、操作函数指针和文件的i节点等。
* Linux将v节点和i节点实现为独立于文件系统的i节点和依赖文件系统的i节点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xi2wq.com1.z0.glb.clouddn.com/linux_Kernel" title="data structures for open files.png" /&gt;
——打开文件的内核数据结构&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xi2wq.com1.z0.glb.clouddn.com/linux_Two" title="independent processes with the same file open.png" /&gt;
——两个独立进程各自打开同一个文件&lt;/p&gt;
&lt;p&gt;不同进程共享文件时，每个进程都有一个该文件的文件表项，指向同一个v节点表。多个文件描述符也可能指向同一个文件表项，如使用 dup 函数和 fork 后的父子进程。&lt;/p&gt;
&lt;h2&gt;4.原子操作&lt;/h2&gt;
&lt;p&gt;原子操作指有多步组成的操作，执行时要么全部执行，要么一步也不执行。
多个进程共享同一个文件，可能造成进程对文件的连续的操作被打乱，这就需要使操作成为原子操作。如 O_APPEND 将到尾端和写入数据组成原子操作，还有 O_CREAT 和 O_EXCL 将检查文件是否存在和创建文件组成原子操作。&lt;/p&gt;
&lt;h3&gt;1.pread和pwrite&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;pread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* 成功返回读到的字节数，已到文件尾返回0，出错返回-1 */&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;pwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* 成功返回写入的字节数，出错返回-1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用pread相当于调用lseek后调用read（原子操作）：
+ 调用pread时，无法中断其定位和读操作
+ 不更新当前文件偏移量  &lt;/p&gt;
&lt;p&gt;pwrite类似&lt;/p&gt;
&lt;h3&gt;2.dup和dup2&lt;/h3&gt;
&lt;p&gt;dup和dup2函数用来复制现有的文件描述符&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dup2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。
dup2,可以用fd2参数指定新描述符的值。如果fd2已经打开，则先将其关闭。若fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xi2wq.com1.z0.glb.clouddn.com/linux_Kernel_data_structures_after_dup_1.png.png" /&gt;
——dup(1)后的内核数据结构&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Sat, 14 Mar 2015 12:15:15 +0800</pubDate><guid>tag:,2015-03-14:yew1eb.github.io/2015/03/linux-file-io.html</guid><category>Linux</category></item><item><title>sizeof</title><link>yew1eb.github.io/2015/03/sizeof.html</link><description>&lt;h3&gt;sizeof&lt;/h3&gt;
&lt;p&gt;1、  结构体的大小等于结构体内最大成员大小的整数倍
2、  结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数。&lt;/p&gt;
&lt;h3&gt;线程安全和线程不安全理解&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/ghevinn/article/details/37764791"&gt;link&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Fri, 13 Mar 2015 16:53:12 +0800</pubDate><guid>tag:,2015-03-13:yew1eb.github.io/2015/03/sizeof.html</guid><category>C/C++</category></item><item><title>Make 编译工具的使用</title><link>yew1eb.github.io/2015/03/make.html</link><description>&lt;h3&gt;Make 编译工具的使用&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://linux.cn/article-4930-weibo.html"&gt;Make命令教程&lt;/a&gt;
&lt;a href="https://www.gnu.org/software/make/manual/make.html"&gt;GNU make&lt;/a&gt;
&lt;a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf"&gt;Cmake&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Fri, 13 Mar 2015 07:52:17 +0800</pubDate><guid>tag:,2015-03-13:yew1eb.github.io/2015/03/make.html</guid><category>Make</category></item><item><title>Linux系统学习笔记：序</title><link>yew1eb.github.io/2015/03/linux-init.html</link><description>&lt;h1&gt;Linux系统学习笔记：序&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;本人使用的Linux为Ubuntu，主要以《APUE》（第3版）为学习蓝本。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;1. Unix/Linux 体系结构&lt;/h3&gt;
&lt;p&gt;如图: &lt;br /&gt;
&lt;img alt="" src="http://7xi2wq.com1.z0.glb.clouddn.com/linux_Architecture" title="of the UNIX operating system.png" /&gt;&lt;br /&gt;
内核的接口被称为系统调用。公用函数库构建在系统调用接口之上，应用程序既可以使用公用函数库，也可使用系统调用。Shell是一个特殊的应用程序，为运行其他应用程序提供了一个接口。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2. Linux 内核的主要模块&lt;/h3&gt;
&lt;h4&gt;2.1 进程调度 SCHED&lt;/h4&gt;
&lt;p&gt;进程调度指的是系统对进程的多种状态之间转换的策略。Linux下的进程调度有3种策略：&lt;br /&gt;
    * SCHED_OTHER  分时调度策略&lt;br /&gt;
    * SCHED_FIFO      实时调度策略，先到先服务 &lt;br /&gt;
    * SCHED_RR         实时调度策略，时间片轮转  &lt;/p&gt;
&lt;h4&gt;2.2 内存管理 MMU&lt;/h4&gt;
&lt;p&gt;内存管理是多个进程间的内存共享策略。在Linux系统中，内存管理的主要概念是虚拟内存。&lt;/p&gt;
&lt;h4&gt;2.3 虚拟文件系统 VFS&lt;/h4&gt;
&lt;p&gt;Linux支持多种文件系统，最常用的文件格式是ext2和ext3(ext4是ext3的改进版)，ext2文件系统用于固定文件系统和可活动文件系统，ext3在ext2的基础增加了日志功能。两者可以互相转换。&lt;/p&gt;
&lt;h4&gt;2.4 网络接口&lt;/h4&gt;
&lt;p&gt;Linux支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。&lt;/p&gt;
&lt;h4&gt;2.5 进程间通信&lt;/h4&gt;
&lt;p&gt;Linux操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux下的进程间的通信方式主要有管道方式、信号方式、消息队列方式、共享内存和套接字等方法。   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(以上内容我将在操作系统和计算网络部分深入学习)&lt;/strong&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;3.  Linux的文件结构&lt;/h3&gt;
&lt;p&gt;一些常用目录的作用： &lt;br /&gt;
1. /bin 包含了引导启动所需的命令或普通用户可能用的命令。&lt;br /&gt;
2. /sbin 类似/bin，也用于存储二进制文件。其中的大部分文件多是系统管理员使用的基本的系统程序。&lt;br /&gt;
3. /root 超级用户的目录。 &lt;br /&gt;
4. /lib 是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。&lt;br /&gt;
5. /lib/modules 包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。&lt;br /&gt;
6. /dev 存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。&lt;br /&gt;
7. /tmp 存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。&lt;br /&gt;
8. /boot 存放引导加载器(bootstrap loader)使用的文件，如l i l o，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。&lt;br /&gt;
9. /mnt 是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱，/mnt/cdrom 光驱等等。&lt;br /&gt;
10. /opt 这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。&lt;br /&gt;
11. /home 主要存放用户同名的目录，并且可以支持ftp的用户管理。&lt;br /&gt;
12. /usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的所有文件一般来自linux发行版( distribution)；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr 目录下的许多内容是 可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。        &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;/usr/x11r6 包含xwindow系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。xwindow系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft windows或m achintos h比较熟悉的话，就不会对x window系统感到束手无策了。  &lt;/li&gt;
&lt;li&gt;/usr/x386 类似/ usr/x11r6 ，但是是专门给x 11 release 5的。  &lt;/li&gt;
&lt;li&gt;/usr/bin 集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。  &lt;/li&gt;
&lt;li&gt;/usr/sbin包括了根文件系统不必要的系统管理命令，例如多数服务程序。  &lt;/li&gt;
&lt;li&gt;/usr/man、/usr/info、/usr/doc 这些目录包含所有手册页、gnu信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如： /usr/man/man1中包含联机手册第一节的源码(没有格式化的原始文件)，/usr/man/cat1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。  &lt;/li&gt;
&lt;li&gt;/usr/include 包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名字。&lt;/li&gt;
&lt;li&gt;/usr/lib 包含了程序或子系统的不变的数据文件，包括一些site-wide配置文件。名字lib来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。  &lt;/li&gt;
&lt;li&gt;/usr/local 本地安装的软件和其他文件放在这里。这与/usr很相似。用户可能会在这发现一些比较大的软件包，如tex、emacs等。  &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;13. /var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了。每个系统是特定的，即不通过网络与其他计算机共享。 下面列出一些重要的目录(一些不太重要的目录省略了)。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;/var/catman 包括了格式化过的帮助(man)页。帮助页的源文件一般存在/usr/man/man中；有些man页可能有预格式化的版本，存在/ usr/man/cat中。而其他的man页在第一次看时都需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。 (/var/catman 经常被清除，就像清除临时目录一样。)  &lt;/li&gt;
&lt;li&gt;/var/lib 存放系统正常运行时要改变的文件。  &lt;/li&gt;
&lt;li&gt;/var/local 存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock。  &lt;/li&gt;
&lt;li&gt;/var/lock 锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。  &lt;/li&gt;
&lt;li&gt;/var/log 各种程序的日志( log )文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不确定地增长，应该定期清除。   &lt;/li&gt;
&lt;li&gt;/var/run 保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。  &lt;/li&gt;
&lt;li&gt;/var/spool 放置“假脱机( spool )”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。  &lt;/li&gt;
&lt;li&gt;/var/tmp 比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp 有很旧的文件。  &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Fri, 13 Mar 2015 05:35:18 +0800</pubDate><guid>tag:,2015-03-13:yew1eb.github.io/2015/03/linux-init.html</guid><category>Linux</category></item><item><title>static有什么作用？</title><link>yew1eb.github.io/2015/03/c_static.html</link><description>&lt;p&gt;面试题：static有什么作用？&lt;/p&gt;
&lt;p&gt;答：在C语言中，static主要定义全局静态变量，定义局部静态变量，定义静态函数&lt;/p&gt;
&lt;p&gt;一、       定义全局静态变量 ：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下特点：&lt;/p&gt;
&lt;p&gt;（1）       在全局数据区内分配内存&lt;/p&gt;
&lt;p&gt;（2）       如果没有初始化，其默认值为0&lt;/p&gt;
&lt;p&gt;（3）       该变量在本文件内从定义开始到文件结束可见&lt;/p&gt;
&lt;p&gt;二、       定义局部静态变量：在局部静态变量前面加上关键字static，该局部变量便成了静态局部变量。静态局部变量有以下特点:&lt;/p&gt;
&lt;p&gt;（1）       该变量在全局数据区分配内存&lt;/p&gt;
&lt;p&gt;（2）       如果不显示初始化，那么将被隐式初始化为0&lt;/p&gt;
&lt;p&gt;（3）       它始终驻留在全局数据区，直到程序运行结束&lt;/p&gt;
&lt;p&gt;（4）       其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。&lt;/p&gt;
&lt;p&gt;三、       定义静态函数：在函数的返回类型加上static关键字，函数即被定义成静态函数。静态函数有以下特点：&lt;/p&gt;
&lt;p&gt;（1）       静态函数只能在本源文件中使用&lt;/p&gt;
&lt;p&gt;（2）       在文件作用域中声明的inline函数默认为static&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;            说明：静态函数只是一个普通的全局函数，只不过受static限制，他只能在文件坐在的编译单位内使用，不能呢个在其他编译单位内使用。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在C++语言中新增了两种作用：定义静态数据成员或静态函数成员&lt;/p&gt;
&lt;p&gt;一，       定义静态数据成员。静态数据成员有如下特点：&lt;/p&gt;
&lt;p&gt;（1）       内存分配：在程序的全局数据区分配&lt;/p&gt;
&lt;p&gt;（2）       初始化和定义：静态数据成员定义时要分配空间，所以不能在类声明中初始化。&lt;/p&gt;
&lt;p&gt;二，       静态成员函数。静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例，静态成员函数主要用于对静态数据成员的操作。&lt;/p&gt;
&lt;p&gt;（1）       静态成员函数没有this指针。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Thu, 12 Mar 2015 12:15:15 +0800</pubDate><guid>tag:,2015-03-12:yew1eb.github.io/2015/03/c_static.html</guid><category>C/C++</category></item><item><title>Pelican文章格式和Markdown基本语法</title><link>yew1eb.github.io/2015/02/first-article.html</link><description>&lt;h2&gt;pelican-blog文章的基本格式&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Title: 标题&lt;br /&gt;
Date: 日期&lt;br /&gt;
Category: 分类&lt;br /&gt;
Tags: 标签&lt;br /&gt;
Slug: 生成的url&lt;br /&gt;
Summary: 描述部分&lt;br /&gt;
正文部分。。。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Markdown基本语法&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Markdown是一个将文本转化为HTML的工具。简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。  &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;基本符号&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;*,-,+ 这3个符号效果都一样&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;换行&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;空白行表示另起一个段落&lt;/li&gt;
&lt;li&gt;在文末加上连续两个空格,表示换行&lt;/li&gt;
&lt;li&gt;连续3个符号，然后回车，表示 hr水平分隔线&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连续#的个数对应h1~h6&lt;/li&gt;
&lt;li&gt;在文字左右各加两个符号，表示加粗&lt;/li&gt;
&lt;li&gt;在文字左右各加一个符号，表示斜体&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行首使用&amp;gt;加上一个空格表示引用段落，可以嵌套使用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;列表&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无序列表使用*、+或-后面加上空格来表示&lt;/li&gt;
&lt;li&gt;有序列表使用数字加英文句号加空格表示&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;代码区域&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行内代码使用反斜杠`表示&lt;/li&gt;
&lt;li&gt;代码段落则是在每行文字前加4个空格或者1个缩进符表示&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ 直接写: [链接文本](url &amp;quot;可选的标题&amp;quot;)
+ 引用: [链接文本][id] ，[id]: url &amp;quot;可选的标题&amp;quot;， 定义部分可以出现在文本中的其他位置，ref一般用数字表示。
+ 简写: url: &amp;lt;url&amp;gt; 链接文本即url
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ 直接写: ![alt_text](url &amp;quot;可选的title&amp;quot;)
+ 引用: ![alt_text][id],预先定义 [id]:url &amp;quot;可选title&amp;quot;
+ 直接使用&amp;lt;img&amp;gt;标签，这样可以指定图片的大小尺寸
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;转义字符&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ \\ 反斜杠  
+ \` 反引号  
+ \* 星号  
+ \_ 下划线  
+ \{\} 大括号  
+ \[\] 中括号  
+ \(\) 小括号  
+ \# 井号  
+ \+ 加号  
+ \- 减号  
+ \. 英文句号  
+ \! 感叹号
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yew1eb</dc:creator><pubDate>Tue, 24 Feb 2015 16:33:00 +0800</pubDate><guid>tag:,2015-02-24:yew1eb.github.io/2015/02/first-article.html</guid><category>pelican</category><category>Markdown</category></item></channel></rss>